<!doctype html><html>
    
<head><title>gravLox</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style id="docStyles">

* {
    box-sizing: border-box;
    word-wrap: break-word;
    --hue: 48;
    --sat: 100%;
    --lit: 88%;
    --color: hsl(var(--hue),var(--sat),var(--lit));
    --backcolor: hsl(120, 100%, 13%);
    --litback: hsla(120,50%,25%);
}

body {
    padding: 0px;
    margin: 0px;
    background-color: #000;
    hyphens: auto;
    text-align: center;
}

#holder {
    display: inline-grid;
    grid-template-columns: 1fr;
    grid-template-rows: 1fr 1fr;
    padding: 10px;
    font-size: 24px;
    text-align: justify;
    max-width: 700px;
    width: 100%;
    height: 100vh;
    margin: auto;
    xxxborder: 1px solid #000;
    background-color: var(--backcolor);
    color: var(--color);
    z-index: 2;
}

#discussion {
    margin: 0px;
    overflow-x: hidden;
    overflow-y: auto;
    min-height: 40px;
}

.addendum {
    font-size: 0.9em;
    opacity: .3;
}

div {
    position: relative;
    margin:0;
    padding:0;
}

hr {
    border-top: 1px solid var(--color);
    border-bottom: none;
    border-left: none;
    border-right: none;
    margin: 50px 0px 50px 0px;
}

img {
    xxxwidth: 100%;
    xxxmax-width: 400px;
}

a, a:visited {
    color: var(--color);
    text-decoration: none;
    transition: 300ms linear color;
}

a:hover {
    color: #e86;
    transition: 300ms linear color;
}

input {
    --thumbH : 40px;
    --color: 48, 100%;
    --lightness: 88%;
    --midness:  var(--lightness);/*calc(0.37 * var(--lightness));*/
}

input[type=range] {
    -webkit-appearance: none;
    -moz-appearance: none;
    display: inline-block;
    padding: 0;
    margin: 0;
    height: var(--thumbH);
    width: 100%;
    border-radius: calc(var(--thumbH) / 2);
    background-color: hsla(0,100%,100%,0.3);
    pointer-events: none;
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    background-color: hsl(var(--color), var(--lightness));
    opacity: 1.7;
    height: var(--thumbH);
    margin-bottom: 0px;
    width: var(--thumbH);
    border: calc(0.1 * var(--thumbH)) solid;
    border-color: var(--backcolor);
    border-radius: calc(var(--thumbH) / 2);
    pointer-events: auto;
}

input[type=range]:focus {
    outline: none;
}

/*possibly a portrait mobi-fone*/
@media screen and (max-width:500px) {
    
    input {
        --thumbH: 30px;
    }
    
    dd {
        font-size: 16px;
        margin-left: 20px;
    }
    
}
  
/*possibly a mobile landscaper*/
@media screen and (orientation: landscape) and (max-width: 760px) {
    
    #holder {
        height: 500px;
        width: 100%;
        max-width: none;
    }
      
}

</style>
<style id="svgStyles">

svg {
    width: 100%;
    padding: 0;
    margin: 0;
}

#svgHolder {
    border: 10px solid hsla(0,100%,100%,0.3);
    position: relative;
    padding: 0;
    margin: 0;
    width: 100%;
    padding-top: calc(40% - 7px);
    overflow: hidden;
    user-select: none;
    --line-width: 2;
    --line-color: 'purple';
    --axis-width: 1;
    --axis-color: #e90;
    --dot-color: var(--color);
    --mass-color: #e90;
    --mass-stroke: #c70;
    --mass-line-width: 0.4;
    --mass-line-color: purple;
    --load-ball-color: #e90;
    --load-ball-stroke: #c70;
}

#gravLox {
    position: absolute;
    right: 0px;
    bottom: 0px;
    padding: 2px;
    opacity: 0.3;
    font-style: italic;
    font-size: 20px;
    color: var(--axis-color);
    user-select: none;
}

#svgGrid {
    padding: 0; margin: 0;
    position: absolute;
    top:0;
    overflow: visible;
    xxxtransform: perspective(400px) rotateX(75deg);
    z-index:-1;
    user-select: none;
}

#svgMass {
    padding: 0; margin: 0;
    top:0;
    position: absolute;
    xxxtransform: perspective(400px) rotateX(-15deg);
    xxxoverflow hidden;
    user-select: none;
}

.gridline {
    stroke-width: var(--line-width);
    stroke: var(--line-color);
    stroke-linecap: round;
    fill: none;
    pointer-events: stroke;
    vector-effect: non-scaling-stroke;
    xxxstroke-dasharray: 10 4;
    xxxstroke-dashoffset: 0;
    xxxanimation: move-grid-line 0.5s linear infinite;
    transition: opacity 1s linear;
}

.xlineDots {
    marker-start: url(#dot);
    marker-mid: url(#dot);
    marker-end: url(#dot);
}

.xline {
    
}

.yline {
    
}

.axisline {
    fill: none;
    stroke: var(--axis-color);
    stroke-width: var(--axis-width);
    vector-effect: non-scaling-stroke;
}

#loadball {
    fill: var(--load-ball-color);
    stroke : var(--mass-stroke);
    stroke-width: 10;
    vector-effect: non-scaling-stroke;
}

.massdot {
    fill: var(--mass-color);
    stroke: none;
}

#massouts {
    transition: opacity 1s linear;
}

.massout {
    fill: none;
    stroke : var(--mass-stroke);
    stroke-width: 5;
    vector-effect: non-scaling-stroke;
}

.massline {
    
    fill: none;
    stroke: var(--mass-line-color);
    stroke-width: var(--mass-line-width);
    xxxstroke-dasharray: 5 1;
    xxxstroke-dashoffset: 0;
    xxxanimation: move-mass-line 2s linear infinite;
    transition: opacity 1s linear;
}

@keyframes move-mass-line {
    0% { stroke-dashoffset: 0; }
    100% { stroke-dashoffset: -6; }
}

@keyframes move-grid-line {
    0% { stroke-dashoffset: 0; }
    100% { stroke-dashoffset: -14; }
}

/*possibly a portrait mobi-fone*/
@media screen and (max-width:500px) {
    
    #svgHolder {
        border-width: 2px;
    }
      
}

</style>
<style id="mathStyles">

frac {
    display: inline-grid;
    grid-template-columns: 1fr;
    grid-template-rows: 1fr 1fr;
    font-style: italic;
    font-size: 0.6em;
    vertical-align: middle;
    text-align: center;
}

num { border-bottom: 1px solid; }
num::before {content: "\00a0\00a0"; }
num::after {content: "\00a0\00a0"; }

sup { font-size: 0.6em; }

com { font-size: 0.5em; }
com::before{ content: "\00a0\00a0\00a0["; }
com::after{ content: "]"; }

whr {
    border-left: 1px solid;
    padding: 0.5em;
    margin-left: 1.25em;
    font-size: 0.7em;
    vertical-align: middle;
}

dd { margin-top: 15px; }

</style>
</head>

<body>
<div id="holder">
    
    <div id="svgHolder">
        
        <div id="gravLox" >grav&middot;LoX</div>
         
        <svg id="svgGrid"
         xmlns:xlink="http://www.w3.org/2000/svg"
         width="100%"
         viewbox="-50 -20 100 40"
         preserveAspectRatio="none"
        >
            <defs>
                
                <marker id="dot" refX="10" refY="10"
                 vector-effect="non-scaling-size"
                 markerUnits="userSpaceOnUse"
                 markerWidth="20"
                 markerHeight="20"
                 orient="auto"
                >
                    <circle cx="10" cy="10" r="0.4"
                     vector-effect="non-scaling-size"
                     fill="var(--dot-color)"
                     stroke="none"
                    ></circle>
                </marker>
        
                <g id="massdots"></g>
                
                <mask id="hole">
                    <rect
                    x="-50" y="-20"
                    width="100%" height="100%" fill="white"/>
                    <use href="#massdots"/>
                </mask>
                
            </defs>
            
            <circle id="loadball" cx="0" cy="0" r="1" transform="scale(0,0)"/>
            
            <g id=gridgroup transform="scale(0,0)" mask="url(#hole)">
                <g id="xgridlines"></g>
                <g id="ygridlines"></g>
            </g>
            
            <!--g id="massdots"></g-->
            
            <g id="massgroup">
                <g id="xmasslines"></g>
                <g id="ymasslines"></g>
            </g>
            
            <g id="massouts"></g>
            
        </svg>

    </div>
        
    <div id="slideDiv" style="
        padding: 10px 0px 5px 0px;
        margin: 0;
    ">
        <input
         id="slide0"
         type="range"
         min="0"
         max="100"
         step="1"
         value="0"
        />
    </div>

    <div id="discussion">
        
        <div id="equation">
        
        <p>
            In this scene, <i>E</i>&nbsp;=&nbsp;m<i>c</i><sup>2</sup>&nbsp;
           
            and you probably recognize that the letter&nbsp;<i>c</i>
            in that equation
            refers to a <i>speed</i>; specifically,
            the speed of light.
        </p>
        
        <p>
            Now, you also know that the little number
            two:&nbsp;<sup>2</sup> means <i>squared</i>,
            which is the same as saying "times itself"
        </p>
        
        <p>
            We can re-write that equation as:
            <dd>
            <i>E</i> = m &middot; <i>c</i> &middot; <i>c</i>
            </dd>
        </p>
        
        <p>
            Normally when you think of speed, you think of it in terms
            of some <i>fraction</i> - that is,
            "some distance per time" as in:
            "miles per hour" or "meters per second" or "furlongs per
            fortnight" - whatever you want, <i>speed</i> is typically
            expressed as some quantity of distance being covered in
            some amount of time.
        </p>
        
        <p>
            That distance could be in any direction, in three dimensions;
            it doesn't <i>have</i> to be in only one dimension.
            Normally you drive straight ahead, but you could go
            left-and-right, forward-and-backwards, or even up-and-down
            if you're flying - so
            speed can be thought of as an amount of <i>space</i>
            being covered in a given <i>time</i>.
        </p>
        
        <p>
            We could say that:
            <dd>
            <i>speed</i> = <frac> <num>space</num> time </frac>
            </dd>
        </p>
        
        <p>
            Exactly how much space being covered, and passing time,
            the speed of light contains is not imporant -
            whatever the
            exact numbers are, we don't care for now; we just need
            to understand that the letter&nbsp;<i>c</i> refers to
            some amount of <frac><num>space</num>time</frac>
        </p>
        
        <p>
            Substituting that fraction for <i>c</i>
            in the equation, we should get:
            <dd>
                <i>E</i> = m &middot; <i>c</i> &middot; <i>c</i>
                <whr>
                <i>c</i> = <frac><num>space</num>time</frac>
                &Implies;
                </whr>
                <br><br>
                <i>E</i> = m
                &middot; <frac><num>space</num>time</frac>
                &middot; <frac><num>space</num>time</frac>
            </dd>
        </p>
        
        <p>
            With a little algebra, we can move one of those fractions
            to the other side:
            <dd>
                <i>E</i> = m
                &middot; <frac><num>space</num>time</frac>
                &middot; <frac><num>space</num>time</frac>
            </dd>
            <dd>
                <i>E</i>
                &middot;
                <frac><num>time</num>space</frac>
                =
                m
                &middot; <frac><num>space</num>time</frac>
                &middot; <frac><num>space</num>time</frac>
                &middot; <frac><num>time</num>space</frac>
                <com>
                 multiply both sides by
                 <frac><num>time</num>space</frac>
                </com>
            </dd>
            <dd>
                <i>E</i>
                &middot;
                <frac><num>time</num>space</frac>
                =
                m
                &middot; <frac><num>space</num>time</frac>
                &middot;
                <frac><num>
                    <strike>space</strike>
                    </num><strike>time</strike>
                </frac>
                &middot;
                <frac><num>
                    <strike>time</strike>
                    </num><strike>space</strike>
                </frac>
                <com> cancel out </com>
            </dd>
             <dd>
                <i>E</i>
                &middot;
                <frac><num>time</num>space</frac>
                =
                m
                &middot; <frac><num>space</num>time</frac>
            </dd>
        </p>

        <p>
            This is the relationship between energy <i>E</i>
            and mass <i>m</i>
            used for the computations
            in this scene.
            Energy and mass are proportional to eachother
            in this way:
        </p>
        
        <p>
            <dd>
                <frac>
                    <num>E &middot; time</num>
                    space
                </frac>
                &prop;
                <frac>
                    <num>m &middot; space</num>
                    time
                </frac>
            </dd>
        </p>
        
        </div>
        
        <hr>
        
        <div id="existing">
        <p>
            When you have a fraction, it means that one thing
            is <i>divided up</i>
            over some other thing - if you have, say $80, and
            you 'divided it up' among ten people, what that
            means is, you're 'spreading out' the eighty dollars
            over the ten people.
        </p>
        
        <p>
            If a farm has 30,000 stalks of corn 'per acre' that means
            the stalks are spread out over the acres.
        </p>
        
        <p>
            What we mean by
            <frac><num>m &middot; space</num> time</frac>
            is that some amount of mass and space is evenly distributed
            over <i>time.</i>
        </p>
        
        <p>
            Saying that something is 'evenly distributed over time'
            just means that the thing <i>exists.</i>
        </p>
        
        <p>
            If an object did not persist for any amount of time,
            then it wouldn't exist by the standards of what
            the term 'exist' typically means.  That an object
            has length and width and depth is only applicable
            if it also has <i>persistence.</i>
        </p>
        
        <p>
            Your company leases a storage unit - the unit is
            rented based on its dimensions, length, width, height,
            but also by its duration, that is, the time of
            the lease. If you have a six-month lease on a storage
            unit, sure your company has access to
            8&times;10&times;12 feets
            of space, but after that six months expires, it's
            no longer applicable to anything your company does.
        </p>
        
        <p>
            Similarly, if there weren't any <i>dimension</i>
            for an object to exist in, then it wouldn't exist.
            If you only had two dimensions, then 'spheres'
            would only exist as whatever circle happens to
            be intersecting the plane of your existence.
            There needs to be some space for mass to occupy.
            Your company better rent a storage unit with
            enough dimensions to hold whatever you need to store.
        </p>
        
        <p>
            By saying
            <frac><num>m &middot; space</num>time</frac>
            we mean that there is some stuff, <i>mass</i>,
            and it occupies some dimension, <i>space</i>,
            and all of that is evenly distributed over
            <i>time</i> - it all persists.
        </p>
        
        </div>
        
        <div id="devouring">
        <p>
            On the other side of the equation, we have
            <frac><num>E &middot; time</num>space</frac>
            by which we mean that there is some amount
            of energy and some time, and all of that is
            evenly distributed throughout space. Both
            energy and time are spread out into the space.
        </p>
        
        <p>
            In this scene, the universe has had a grid
            laid out over it, in order for you to visualize
            it more easily - each section of the grid
            contains some amount of energy as well as some time.
        </p>
        
        <p>
            Scrolling over the scene causes specific locations
            to begin <i>consuming</i> the universe around them.
            [Scroll left-to-right over the scene, or drag the
            slider - click in the slider bar to animate.]
        </p>
        
        <p>
            These locations devour the surrounding grid
            and convert that into an object; an object
            that occupies the dimensions that were converted
            from the space around them, and which
            persists throughout the time which was also
            pulled through from the grid.
        </p>
        
        <p>
            That is to say, when you start scrolling,
            things start moving from one side of the
            equation to the other.
            <dd>
                <i>E</i> &middot; <frac><num>time</num>space</frac>
                &nbsp;
                &rrarr;
                &#x21f6;
                &nbsp;
                m &middot; <frac><num>space</num>time</frac>
            </dd>
            <br>
            Initially, nothing exists on the <i>mass</i>
            side of the equation.
            When you start scrolling,
            objects get formed; those objects need some dimensions
            to occupy.  The dimensions they occupy are the ones
            sucked through from the space on the other side of the
            equation. The objects and the dimensions need to persist
            for some time; the time they exist during is the time
            from the other side of the equation.
        </p>
        
        <p>
            Again, the masses ingest the grid, and turn
            it into more mass - this consumption causes
            the grid to warp.
            Eventually, the distortion forms a very strong
            and noticable connection between the
            centers of each object.
        </p>
        </div>
        
        <div id="denial">
        <p>
            The grid does not warp to accomodate the mass;
            neither does the presence of the mass cause
            space to warp.
        </p>
        
        <p>
            The masses <i>are</i> the wrapping of space
            up into a ball.
            Energy and time-space are sucked through to
            the opposite side of the equation, and that
            forms an object.
        </p>
        
        <p>
            The 'attraction' the objects have towards
            eachother's center <i>is</i> the distortion
            that occurs as the objects swallow the
            surrounding grid-space.
        </p>
        </div>
        
        <hr>
        
        <div id="fabric">
        <p>
            <i>If</i> space-time is a 'fabric', imagine that
            fabric laid out on a table.  Then, <i>pinch</i>
            the fabric somewhere in the middle and start
            crumpling it up into a ball in your hand.
            <br><br>
            Eventually, the fabric will be distorted and
            wrinkled up, and there will appear to be a ball
            in the middle of it.  There <i>isn't</i> a ball,
            or an object, or a mass, or anything - it's just
            the fabric being crunched up.  The fabric isn't
            distorting because of some object that's inside
            it - the object IS the distortion of the fabric.
        </p>
        
        <p>
            Now imagine that someonelse <i>also</i> starts
            pinching the fabric in a different place.
            [This is a big piece of fabric - imagine it's
            a large bed sheet, and it's spread out on the
            floor.]
            <br><br>
            You both pinch the sheet at a different place
            somewhere in the
            middle and start crumpling it up into a ball.
            After a little while, your hands are
            going to start getting closer to eachother.
            <br><br>
            That is, since you're both pulling the sheet
            into your hands, the part of the sheet that's
            between your two hands is getting pulled into
            both of your hands at once; unless you <i>tear</i>
            the sheet [don't tear the sheet! you'll get
            in trouble], your hands will start getting
            closer to eachother until the two wads of
            fabric you're both crunching up touch one another,
            and become a single big ball.
            
            If we're both eating the same string of spaghetti,
            from opposite sides, either the spaghetti is going
            to snap, or we're going to kiss.
            <br><br>
            
            Again, there is no force pulling the two things
            together - the 'pulling force' is the wadding
            up of the sheet into a ball.  It's the
            drawing up of the sheet into a ball that appears
            to draw the two things together.
            <br><br>
            <i>And</i> there aren't 'things' - there just
            appear to be things because the sheet is
            crunched up in different places.
        </p>
        
        <p>
            [Note that this animation does not show the
            part where the masses start getting closer
            to eachother - though it could, ofcourse, do
            that from the same calculation; it's simply
            intended to emphasize, for now, the
            grid-becoming-mass portion of what's happening.
            <br><br>
            You should also be able to see that the masses
            are 'attracted' in <i>many</i> directions
            at once - along every different line in the
            grid, in fact - it's just that a preponderance
            of grid-lines has been concentrated between
            the 'centers of mass' of each object.]
        </p>
        </div>
        
        <hr>
        
        <div id="boxing">
        
        <p>
            Make a box ...
            <p style="width:100%;text-align:center;">
            <img src="sketchBox.svg"
            style="width:200px;">
            </p>
            You got it? It's a box; it's got all the parts,
            length, width, height - it even exists for some
            period of time. It contains all of the dimensions
            that a box usually has.
        </p>
        
        <p>
            Now, <i>conceptually,</i> collapse the box,
            in one direction; squoosh it down into a square ...
            <p style="width:100%;text-align:center;">
            <img src="collapsingBox.svg"
            style="width:200px;">
            </p>
            Alright? It <i>still has</i> all of its dimensions.
            We are just going to use this plane as a
            representation of the dimensional space of
            the box - we're going to imagine that
            one of the box's dimensions has been flattened
            down so far that the box now looks like a square.
            All of the dimension, and space, and everthing
            that was originally inside the box is still there;
            we're simply using a flat plane to represent
            the whole box.
        </p>
        
        <p>
            Now do that same thing with <i>another box</i>;
            a different box that has been divided up using
            a grid ...
            <p style="width:100%;text-align:center;">
            <img src="collapsingGrid.svg"
            style="width:200px;">
            </p>
            The length, width, height, depth, time,
            everything is still in there, we're just
            collapsing one of the directions so that we
            can use a square to represent the entire box.
        </p>
        
        <p>
            At this point, we have two different
            <i>planes of existence.</i> We have two
            squares, or planes, that are representative
            of fully-dimensional realms.
        </p>
        
        <p>
            Take the two planes, and <i>intersect them</i>...
            <p style="width:100%;text-align:center;">
            <img src="intersectionPlanes.svg"
            style="width:300px;">
            </p>
            That is, effectually, what is happening in
            this scene.
            <br><br>
            There are two separate <i>realms of existence</i>.
            
            One of them is the 'mass realm', the
            <frac><num>m &middot; space</num> time </frac>
            side of the equation. The other is the
            'energy realm' or the
            <frac><num>E &middot; time</num> space </frac>
            side of the equation.
            <br><br>
            
            Initially, the mass-realm is completely empty;
            there is nothing in it - no length or
            width or height or mass.  At first, the mass-realm
            doesn't even <i>exist</i> because it doesn't
            even have the time it would need in order to exist.
            <br><br>
            
            In the beginning of the scene, the <i>energy-realm</i>
            exists. It has a grid laid out over it;
            time and energy are spread throughout the space.
            That particular realm is teaming with energy
            and time, and all of that is contained in
            dimensions.  Here, we've visualized that as
            a grided-plane.
            <br><br>
            
            As the grid gets ingested, things begin to
            'transfer' into the mass-realm.
            Things from the <i>Energy</i> side of the
            equation begin projecting into the
            mass-realm...
            <p style="width:100%;text-align:center;">
            <img src="intersectionMass.svg"
            style="width:300px;">
            </p>
            Remember that the mass side of the equation
            does not exist at first; as things
            move from one side of the equation,
            they <i>construct</i> the other.
            The energy and grid-lines get projected
            through <i>as mass</i>; the dimensions
            transfer through to create the length
            and width and height needed to hold the
            mass; the time gets transposed into
            the time needed for everything to persist.
            <br><br>
            This happens with every mass in the scene.
        </p>
        
        <p>
            It would either be confusing or impractical
            to attempt to show two different three-dimensional
            realities intersecting eachother at right angles,
            which is why they were reduced to planes for
            this example.
        </p>
        </div>
        
        <hr>
        
        <div id="projection">
            
            It might be a little easier to see what a single line
            is doing if you look at just one line.
            <br><br>
            <div id="toggleDiv" style="
                width:100%;
                text-align:center;
                user-select:none;
            "><i>~~ click to toggle ~~</i></div>
            <br>
            [Double-clicking the scene will also toggle the lines.]
            <br><br>
            
            Again, the masses are not masses - they are conceptual
            locations, indicated by coordinates, that consume
            the grid in all directions, then spit it back out
            into the mass-realm.  When those lines get projected
            out into the other side of the equation, that takes
            the shape of a circle.
            
        </div>
        
        <div id="emergency">
            
            <p>
            The grid does not warp to accomodate the mass.
            The masses do not distort the grid with their presence.
            The objects are not drawn towards eachother.
            There is no gravity.
            There are no objects.
            </p>
            
        </div>

        <p class="addendum"></p>
        
        <p id="sig" style="text-align:right;width:100%"><i>~queviva</i></p>
        
        
    </div>
  
</div>
</body>

<script id="gravscript">


// expiration date {
new Date() < new Date('2023-10-13') &&

((dset = document.currentScript.dataset) =>

  document.addEventListener('DOMContentLoaded', () => {
      
//}
    
        ////////////////////////////////////////////////////////////
        
        // preferences {
        
        const appName = 'grav&middot\;LoX';
    
        const size = 2;
        const xdim = 70;
        const ydim = 40;
        
        const numSteps = 100;
        const aniStall = 10;
        const valScale = 0.8;
        const useDots = false;
        const aniMass = false;
        
        const massLineVelocity = 0.001; // in pixels-per-timestep
        
        const cssProps = {
            'line-width' : 0.4,
            'line-color' : 'hsla(48,100%,88%,1.0)',
            'axis-width' : 0.6,
            'axis-color' : 'rgba(255,165,0,1.0)',
            'mass-color' : 'black',//'rgba(255,165,0,1.0)',
            'mass-stroke' : 'rgba(255,165,0,1.0)',//'rgba(204,119,0,1.0)',
            'mass-line-width' : 0.1,
            'mass-line-color' : 'rgba(255,165,0,1.0)',
            'load-ball-color' : 'rgba(255,165,0,1.0)',
            'load-ball-stroke' : 'rgba(204,119,0,1.0)',
        };
        
        let masses = [
            
            //[int x, int y, int first_step]
            // equilateral {
            //[ 0, -12, 5, 0],
            //[-12,  4, 5, 0],
            //[ 12,  4, 5, 0]
            // }
            
            // [0, 0, 12, 0]
            
             [-24,  -8,  0]
            ,[ 26,   8, 20]
            ,[-35,  12, 80]
            //,[ 32, -10, 85]
        ];
    
        //}
    
        // references {
        
        let count = 0;
        let loadCount = 0;
    
        const NS = 'http://www.w3.org/2000/svg';
        const svgHolder = document.getElementById('svgHolder');
        const xlines = document.getElementById('xlines');
        const ylines = document.getElementById('ylines');
        const loadball = document.getElementById('loadball');
        const gridgroup = document.getElementById('gridgroup');
        const massgroup = document.getElementById('massgroup');
        const massdots = document.getElementById('massdots');
        const massouts = document.getElementById('massouts');
        
        const slideDiv = document.getElementById('slideDiv' );
        const slide0 = document.getElementById('slide0' );
        slide0.disabled = true;
    
        const toggleDiv = document.getElementById('toggleDiv');
        
        let xPts = (new Array(1 + (2 * ydim))).fill(0);
        let yPts = [];
        
        let xlineObjs = [];
        let ylineObjs = [];
        
        let merms = [];
        
        //}
    
        // methods {
        
        const getDist = (A, B) => Math.sqrt( //{
            Math.pow(A.x - B.x, 2) +
            Math.pow(A.y - B.y, 2) //+
          //Math.pow(A.z - B.z, 2) the mythical third dimension
        ); //}
        
        const toggle = () => {
            
            if (gridgroup.getAttribute('mask') !== 'none') {
        
                gridgroup.setAttribute('mask', 'none');
                massouts.style.opacity = 0.0;
        
                [...xlineObjs, ...ylineObjs].forEach(L => {
                    if (!L.gridobj.classList.contains('axisline')) {
                        L.gridobj.style.opacity = 0.0;
                        L.massobj.style.opacity = 0.0;
                    }
                });
        
        
            } else {
        
                gridgroup.setAttribute('mask', 'url(#hole)');
                massouts.style.opacity = 1.0;
        
                [...xlineObjs, ...ylineObjs].forEach(L => {
                    if (!L.gridobj.classList.contains('axisline')) {
                        L.gridobj.style.opacity = 1.0;
                        L.massobj.style.opacity = 1.0;
                    }
                });
            }
        };

        //}
            
        // Point Object {
        
        function Point (x, y) {
    
            this.x = x;
            this.y = y;
            
            this.thetas = [];
            this.acc = [];
            
            this.mem = new Array(100);
            this.mem[0] = { x: x, y: y };
            
            this.threshold = Infinity;
            
            this.transPoint = {
                dex: null,
                x: null,
                y: null,
                cos: null,
                sin: null
            };
    
        }
        
        Point.prototype.addAcc = function (m, step) {
        
            let dist = getDist(m, this);
        
            if (dist === 0 && m.first === step) {
                this.mem.fill({ x: this.x, y: this.y }, step);
                this.acc[m.dex] = 0;
                return;
            }
        
            this.acc[m.dex] = 1 / (dist * dist);
        
            this.thetas[m.dex] = Math.atan2(
                this.y - m.y,
                this.x - m.x
            );
            
        };
        
        Point.prototype.recalc = function (step = 0) {
            
            // if this step is already calculated skip out
            if (this.mem[step]) { return; }
            
            // if this point has already transitioned realms ...
            if (step > this.threshold) {
                
                // compute the distance to travel
                let D = massLineVelocity *
                       (step - this.threshold) *
                       (step - this.threshold);
                
                // update the mass-realm coords
                this.x = this.transPoint.x + (this.transPoint.cos * D);
                this.y = this.transPoint.y + (this.transPoint.sin * D);
                
                // set the positions for this step
                this.mem[step] = { x: this.x, y: this.y };
                
                // and finish
                return;
                
            }
            
            // otherwise, scale the change in time
            let dT = step * valScale;
            
            // begin amassing change in position
            let dx = 0;
            let dy = 0;
    
            // loop through every emerged mass
            for (let m of merms) {
                
                // figure out the angle to that mass at this step
                let theta = Math.atan2(
                    m.y - this.y,
                    m.x - this.x
                );
                
                // adjust the change in time
                let adj = (step - m.first) * valScale;
                
                // compute the distance to travel
                let D = this.acc[m.dex] * adj * adj;
                
                // compound the position deltas
                dx += D * Math.cos(theta) || 0;
                dy += D * Math.sin(theta) || 0;
                
            }
    
            // update the coords
            this.x += dx;
            this.y += dy;
            
            // add them to the memory for this step
            this.mem[step] = { x: this.x, y: this.y };
            
            // loop through all emerged masses ...
            for (let m of merms) {
                
                // if this point has transitioned realms ...
                if (Math.sqrt(dx*dx + dy*dy) >= getDist(m, this)) {
                    
                    // set the threshold to this step
                    this.threshold = step;
                    
                    // remember the transition-point info
                    this.transPoint = {
                        dex: m.dex,
                        x: m.x,
                        y: m.y,
                        cos: Math.cos(this.thetas[m.dex]),
                        sin: Math.sin(this.thetas[m.dex])
                    };
                    
                    // overwrite the coords for this step
                    this.mem[step] = { x: m.x, y: m.y };
                    
                    // skip out
                    break;
                    
                }
            }
            
        };
        
        Point.prototype.makeSVG = function (step = 0) {
            return this.mem[step].x.toFixed(3) + ' ' +
                   this.mem[step].y.toFixed(3) + ' ';
        };
        
        Point.prototype.transSVG = function (step = 0) {
            return this.transPoint.x.toFixed(3) + ' ' +
                   this.transPoint.y.toFixed(3) + ' ';
        };
    
        //}
        
        // Line Object {
        
        function Line (gridobj, massobj, pts) {
            
            this.gridobj = gridobj;
            this.massobj = massobj;
            
            this.pts = pts;
            this.gridpaths = [];
            this.masspaths = new Array(numSteps + 1).fill('');
            
        }
        
        Line.prototype.genPath = function (step = 0) {
            
            // start grid path with zer0-ith point
            let tmpGD = 'M' + this.pts[0].makeSVG(step);
            
            // loop through all the remaining points
            for (let i = 1, j = this.pts.length; i < j; i++) {
                
                // if the point is past its threshold ...
                if (step > this.pts[i].threshold) {
                    
                    // use the transition point
                    tmpGD += 'L' + this.pts[i].transSVG();
                    
                } else { // otherwise ...
                
                    // use the coords of this point
                    tmpGD += 'L' + this.pts[i].makeSVG(step);
                    
                }
                
            }
            
            // set this path to the grid-path for this step
            this.gridpaths[step] = tmpGD;
            
            // get all the mass points from this line
            let massPts = this.pts.filter(p => step > p.threshold);
            
            // loop through each mass
            masses.forEach(m => {
                
                // start a mass line at that mass location
                let tmpMD = 'M' + m.x +' '+ m.y;
                
                // get all the points for just this mass
                massPts.filter(p => p.transPoint.dex === m.dex)
                .forEach(mp => {
                    
                    // add that point to this path
                    tmpMD += 'L' + mp.makeSVG(step);
                    
                });
                
                // add this mass-line to the mass-lines for this step
                this.masspaths[step] += tmpMD + 'Z';
                
            });
            
        };
        
        Line.prototype.drawPath = function (step = 0) {
            this.gridobj.setAttribute('d',this.gridpaths[step] || 'M0 0Z');
            this.massobj.setAttribute('d',this.masspaths[step] || 'M0 0Z');
        };
        
        //}
        
        // Mass Object {
        
        function Mass (dex, x, y, first = 0) {
            
            this.x = x;
            this.y = y;
            
            this.dex = dex;
            this.first = first;
            
            this.rads = [];
            
            ['dot', 'out'].forEach(t => {
                this[t] = document.createElementNS(NS, 'circle');
                this[t].setAttribute('cx', x);
                this[t].setAttribute('cy', y);
                this[t].setAttribute('r', 0);
                this[t].classList.add('mass'+t);
            });
            
            massdots.appendChild(this.dot);
            massouts.appendChild(this.out);
    
        }
    
        Mass.prototype.genPath = function (step = 0) {
            
            // compute adjusted radius for this step
            let adj = step < this.first ? 0 :
                     (step - this.first - 2) < 0 ? 0 :
                     (step - this.first - 2);
                      
            this.rads[step] = massLineVelocity * adj * adj;
            
        };
        
        Mass.prototype.drawPath = function (step = 0) {
            
            this.dot.setAttribute('r', this.rads[step]);
            this.out.setAttribute('r',
                this.rads[step] - 0.2 < 0 ? 0 : this.rads[step] - 0.2
            );
            
        };
        
        //}
        
        // lizzers {
        const lizzers = [
            
            // increment on scroll {
            [svgHolder, 'wheel', e => {
            
                // stop the browser from going back-button-ward
                e.preventDefault();
                
                // if the scroll was big enough ...
                if (Math.abs(e.deltaX) > 5) {
                    
                    // if the animation is running ...
                    if (aniMaker.isLooping !== false) {
                        
                        // stop the loop
                        aniMaker.stop();
                        
                    }
                    
                    // increment the count
                    incCount(Math.sign(e.deltaX));
                    
                    // adjust slider
                    slide0.value = count;
                    
                    update(count);
            
                }
            
            }],
            // }
            
            // increment on slide {
            [slide0, 'input', e => {
                
                e.stopPropagation();
                
                // if animation is running ...
                if (aniMaker.isLooping !== false) {
                    
                    // stop the loop
                    aniMaker.stop();
                    
                }
                
                // increment by the value
                count = parseInt(slide0.value, 10),
                update(count);
                
            }],
            //}

            // animate on slider div click {
            [slideDiv, 'click', e => {
                
                // get the direction from the click
                let dir = [1,-1][
                    (100 *
                    (e.clientX - slideDiv.offsetLeft - holder.offsetLeft)
                    / slideDiv.offsetWidth
                    > slide0.value) ?
                    0 : 1
                ];
                
                // if the animation is already running ...
                if (aniMaker.isLooping !== false) {
                    
                    // and running in the OPPOSITE direction ...
                    if (dir !== aniMaker.dir) {
                        
                        // change the direction
                        aniMaker.dir = dir;
                        
                    } else { // otherwise it is running in the same dir ...
                    
                        // so, stop the loop
                        aniMaker.stop()
                        
                    }
                    
                } else { // if the animation is not running ...
                
                    // start the animation
                    aniMaker.start(dir);
                    
                }
                
            }],
            //}

            // swallow clicks directly on thumb {
            [slide0, 'click', e => {
                e.stopPropagation();
                e.cancelBubble = true;
            }],
            //}
            
            // toggle on div click {
            [toggleDiv, 'click', toggle],
            //}
            
            // reset on scene double-click {
            [svgHolder, 'dblclick', e => {
                
                e.preventDefault();
                
                // if animation is running ...
                if (aniMaker.isLooping !== false) {
                    
                    // stop the loop
                    aniMaker.stop();
                    
                }
                
                count = 0;
                slide0.value = 0;
                update();
                
                //removeLizzers();
                //randReset();
                //xlineObjs.forEach(L => L.paths = [])
                //ylineObjs.forEach(L => L.paths = [])
                //setTimeout(loader,0);
                
            }],
            //}
    
        ];
        //}
                
        function removeLizzers () {
            
            for (const [x, y, z] of lizzers) {
                x.removeEventListener(y, z, { passive: false });
            }
            
        }
        
        function update(step) {
            
            // draw the masses
            masses.forEach(M => M.drawPath(step));
            
            // draw the x-lines
            xlineObjs.forEach(L => L.drawPath(step));
    
            // draw the y-lines
            ylineObjs.forEach(L => L.drawPath(step));
    
        }
        
        function incCount(val) {
            
            // make a copy of the count
            let c = count;
            
            // increment the count gated between zero and a hundred
            count = [0, count + val, 100].sort((a, b) => a - b)[1];
            
            // if the count has actually changed ...
            if (c !== count) {
                
                // redraw the scene
                update();
                
            }
        
        }

        const aniMaker = new function () {
            
            // javascript is NOT an object oriented language
            // it can NOT 'bind this' no matter what they tell you
            // you have to make a _this_ reference
            const nm = this;
            
            // have no direction initially
            nm.dir = 0;
            
            // set a pause for the loop
            nm.stall = aniStall;
        
            // create loop thread var
            nm.isLooping = false;
        
            // the animation function
            nm.anim = dir => {
                
                // if it still needs to run ...
                if (
                    (count < 100 && count > 0)
                    ||
                    (count === 0 && dir === 1)
                    ||
                    (count === 100 && dir === -1)
                ) {
                    
                    // call the increment
                    incCount(nm.dir);
                    
                    // adjust the slider
                    slide0.value = count;
                    
                    // redraw the scene
                    update(count);
        
                    // recall the loop
                    nm.isLooping = setTimeout(function() {
                        nm.anim(nm.dir);
                    }, nm.stall);
        
                }
                // otherwise stop the loop
                else {
        
                    clearTimeout(nm.isLooping);
                    nm.isLooping = false;
        
                }
        
            }
        
            nm.start = dir => {
            
                clearTimeout(nm.isLooping);
                nm.dir = dir;
                this.anim(nm.dir);
        
            };
        
            nm.stop = () => {
        
                clearTimeout(nm.isLooping);
                nm.isLooping = false;
        
            };
        
        }();
        
        // loader {
        function loader () {
            
            // if it still needs to load ...
            if (loadCount < numSteps + 1) {
                
                // recalc the radius for all masses
                masses.forEach(M => M.genPath(loadCount));
                
                // if any masses emerge at this step ...
                masses.filter(m => m.first === loadCount).forEach(m => {
                    
                    // add them to every point
                    for (let AP of xPts) { for (let p of AP) {
                        p.addAcc(m, loadCount);
                    }}
                    
                });
                
                // update the emerged masses list
                merms = masses.filter(m => m.first <= loadCount);
    
                // recalc all the points
                for (let AP of xPts) { for (let p of AP) {
                    p.recalc(loadCount);
                }}
                
                // generate the path for all the lines
                xlineObjs.forEach(L => L.genPath(loadCount));
                ylineObjs.forEach(L => L.genPath(loadCount));
                
                // increment the load count
                loadCount++;
                
                // display percent complete
                gravLox.innerHTML = (100*loadCount/numSteps).toFixed(0) + '%';
                
                // scale the loading mass-energy
                let per = loadCount / (numSteps + 1);
                
                loadball.setAttribute(
                    'transform',
                    'scale(' + (1 - per) * 55 + ','+ (1 - per) * 55 +')'
                );
                
                loadball.style.opacity = 1 - per * per;
               
                // scale the grid as a vizual loader
                gridgroup.setAttribute(
                    'transform',
                    'scale(' + per + ','+ per +')'
                );
                
                // fade the grid as a vizualizer
                gridgroup.style.opacity = loadCount/numSteps;
                
                // total recall
                setTimeout(loader, 0);
                
            } else { // otherwise ...
            
                // reset the load count to zero
                loadCount = 0;
                
                // reset the gravlox logo
                gravLox.innerHTML = appName;
                
                // load the listeners
                for (const [x, y, z] of lizzers) {
                    x.addEventListener(y, z, { passive: false });
                }
                
                // enable the slider
                slide0.disabled = false;
                
                // unscale the grid area
                gridgroup.style.transform = 'none';
                
                // opacify the grid area
                gridgroup.style.opacity = 'none';
                
                // hide the loading ball
                loadball.style.display = 'none';
                
                // try to free some memory
                xPts = null;
                yPts = null;
                
            }
            
        }
        
        //}
        
        ////////////////////////////////////////////////////////////
        // init :::
        
        // set the css vars {
        for (const [keys, vals] of Object.entries(cssProps)) {
            svgHolder.style.setProperty('--'+keys, vals);
        }
        // }
        
        // create the masses {
        masses = masses.map((m, i) => new Mass(i, ...m));
        //}
            
        // fill the points arrays {
        for (let L in xPts) {
            
            // zero-fill twice the x-dimension plus one for axis
            xPts[L] = (new Array(1 + (2 * xdim))).fill(0)
            
            // remap the zeros to points at apropos coords
            .map((p, i) =>
                new Point((i - xdim) * size, (L - ydim) * size)
            );
            
        }
    
        // then rotate that points matrix for y-lines
        for (let L in xPts[0]) {
    
            yPts[L] = [];
    
            for (let i in xPts) {
                yPts[L].push(xPts[i][L]);
            }
    
        }
        //}
        
        // create x-line svgs and objs {
        for (let L of xPts) {
            
            let tmpGL = document.createElementNS(NS, 'path');
            let tmpML = document.createElementNS(NS, 'path');
        
            tmpGL.classList.add('gridline', 'xline');
            tmpML.classList.add('massline');
        
            if (useDots) { tmpL.classList.add('xlineDots'); }
        
            xgridlines.append(tmpGL);
            xmasslines.append(tmpML);
        
            xlineObjs.push(new Line(tmpGL, tmpML, L));
        
        }
        // make the centerline the axis
        xlineObjs[ydim].gridobj.classList.add('axisline');
        //}
        
        // create y-line svgs and objs {
        for (let L of yPts) {
        
            let tmpGL = document.createElementNS(NS, 'path');
            let tmpML = document.createElementNS(NS, 'path');
        
            tmpGL.classList.add('gridline', 'yline');
            tmpML.classList.add('massline');
        
            ygridlines.appendChild(tmpGL);
            ymasslines.appendChild(tmpML);
        
            ylineObjs.push(new Line(tmpGL, tmpML, L));
        
        }
        // make the center line the axis
        ylineObjs[xdim].gridobj.classList.add('axisline');
        //}
        
        // gen and draw grid at step zer0 {
        xlineObjs.forEach(L => {
            L.genPath(0);
            L.drawPath(0);
        });
        ylineObjs.forEach(L => {
            L.genPath(0);
            L.drawPath(0);
        })
        //}

        // run the loader {
        setTimeout(loader, 0);
        //}


// expire msg {
    
}))()

=== undefined || (console.log('eXp!red'));

// }

</script>

</html>