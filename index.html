<!doctype html>
<html>

<head>
	<title>gravLox</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" type="image/x-icon" href="favicon.ico">
	<style id="docStyles">
		* {
			box-sizing: border-box;
			word-wrap: break-word;
			--hue: 48;
			--sat: 100%;
			--lit: 88%;
			--color: hsl(var(--hue), var(--sat), var(--lit));
			--backcolor: hsl(120, 100%, 13%);
			--litback: hsla(120, 50%, 25%);
		}

		body {
			padding: 0px;
			margin: 0px;
			background-color: #000;
			hyphens: auto;
			text-align: center;
		}

		#holder {
			display: inline-grid;
			grid-template-columns: 1fr;
			grid-template-rows: 1fr 1fr;
			padding: 10px;
			font-size: 24px;
			text-align: justify;
			max-width: 700px;
			width: 100%;
			height: 100vh;
			margin: auto;
			xxxborder: 1px solid #000;
			background-color: var(--backcolor);
			color: var(--color);
			z-index: 2;
		}

		#discussion {
			margin: 0px;
			overflow-x: hidden;
			overflow-y: auto;
			min-height: 40px;
		}

		.addendum {
			font-size: 0.9em;
			opacity: .3;
		}

		div {
			position: relative;
			margin: 0;
			padding: 0;
		}

		hr {
			border-top: 1px solid var(--color);
			border-bottom: none;
			border-left: none;
			border-right: none;
			margin: 50px 0px 50px 0px;
		}

		img {
			xxxwidth: 100%;
			xxxmax-width: 400px;
		}

		a,
		a:visited {
			color: var(--color);
			text-decoration: none;
			transition: 300ms linear color;
		}

		a:hover {
			color: #e86;
			transition: 300ms linear color;
		}

		input {
			--thumbH: 40px;
			--color: 48, 100%;
			--lightness: 88%;
			--midness: var(--lightness);
			/*calc(0.37 * var(--lightness));*/
		}

		input[type=range] {
			-webkit-appearance: none;
			-moz-appearance: none;
			display: inline-block;
			padding: 0;
			margin: 0;
			height: var(--thumbH);
			width: 100%;
			border-radius: calc(var(--thumbH) / 2);
			background-color: hsla(0, 100%, 100%, 0.3);
			pointer-events: none;
		}

		input[type=range]::-webkit-slider-thumb {
			-webkit-appearance: none;
			background-color: hsl(var(--color), var(--lightness));
			opacity: 1.7;
			height: var(--thumbH);
			margin-bottom: 0px;
			width: var(--thumbH);
			border: calc(0.1 * var(--thumbH)) solid;
			border-color: var(--backcolor);
			border-radius: calc(var(--thumbH) / 2);
			pointer-events: auto;
		}

		input[type=range]:focus {
			outline: none;
		}

		/*possibly a portrait mobi-fone*/
		@media screen and (max-width:500px) {

			input {
				--thumbH: 30px;
			}

			dd {
				font-size: 16px;
				margin-left: 20px;
			}

		}

		/*possibly a mobile landscaper*/
		@media screen and (orientation: landscape) and (max-width: 760px) {

			#holder {
				height: 500px;
				width: 100%;
				max-width: none;
			}

		}
	</style>
	<style id="svgStyles">
		svg {
			width: 100%;
			padding: 0;
			margin: 0;
		}

		#svgHolder {
			border: 10px solid hsla(0, 100%, 100%, 0.3);
			position: relative;
			padding: 0;
			margin: 0;
			width: 100%;
			padding-top: calc(40% - 7px);
			overflow: hidden;
			user-select: none;
			--line-width: 2;
			--line-color: 'purple';
			--axis-width: 1;
			--axis-color: #e90;
			--ani-color: #c30;
			--dot-color: var(--color);
			--mass-color: #e90;
			--mass-stroke: #c70;
			--mass-stroke-width: 5;
			--mass-line-width: 0.4;
			--mass-line-color: purple;
			--load-ball-color: #e90;
			--load-ball-stroke: #c70;
		}

		#gravLox {
			position: absolute;
			right: 0px;
			bottom: 0px;
			padding: 2px;
			opacity: 0.3;
			font-style: italic;
			font-size: 20px;
			color: var(--axis-color);
			user-select: none;
		}

		#menu {
			position: absolute;
			top: 0px;
			right: 0px;
			background-color: rgba(0, 0, 0, 0.3);
			overflow: hidden;
			visibility: hidden;
			transition: height linear 250ms;
		}

		input[type=checkbox] {

			width: 30px;
			height: 30px;
			vertical-align: middle;
			accent-color: var(--axis-color);

		}

		label {
			font-style: italic;
		}

		#svgGrid {
			padding: 0;
			margin: 0;
			position: absolute;
			top: 0;
			overflow: visible;
			xxxtransform: perspective(400px) rotateX(75deg);
			z-index: -1;
			user-select: none;
		}

		#svgMass {
			padding: 0;
			margin: 0;
			top: 0;
			position: absolute;
			xxxtransform: perspective(400px) rotateX(-15deg);
			xxxoverflow hidden;
			user-select: none;
		}

		.gridline {
			stroke-width: var(--line-width);
			stroke: var(--line-color);
			stroke-linecap: round;
			fill: none;
			pointer-events: stroke;
			vector-effect: non-scaling-stroke;
			xxxtransition: opacity 1s linear;
		}

		.xlineDots {
			marker-start: url(#dot);
			marker-mid: url(#dot);
			marker-end: url(#dot);
		}

		.xline {}

		.yline {}

		.axisline {
			fill: none;
			stroke: var(--axis-color);
			stroke-width: var(--axis-width);
			vector-effect: non-scaling-stroke;
		}

		.aniline {
			stroke-dasharray: 10 4;
			stroke-dashoffset: 0;
			animation: move-grid-line 0.5s linear infinite;
		}

		#loadball {
			fill: var(--load-ball-color);
			stroke: var(--load-ball-stroke);
			stroke-width: 10;
			vector-effect: non-scaling-stroke;
		}

		.massdot {
			fill: var(--mass-color);
			stroke: none;
		}

		#massouts {
			transition: opacity 1s linear;
		}

		.massout {
			fill: none;
			stroke: var(--mass-stroke);
			stroke-width: var(--mass-stroke-width);
			vector-effect: non-scaling-stroke;
		}

		.massline {
			fill: none;
			stroke: var(--mass-line-color);
			stroke-width: var(--mass-line-width);
			vector-effect: non-scaling-stroke;
			xxxstroke-dasharray: 5 1;
			xxxstroke-dashoffset: 0;
			xxxanimation: move-mass-line 2s linear infinite;
			transition: opacity 1s linear;
		}

		@keyframes move-mass-line {
			0% {
				stroke-dashoffset: 0;
			}
			100% {
				stroke-dashoffset: -6;
			}
		}

		@keyframes move-grid-line {
			0% {
				stroke-dashoffset: 0;
			}
			100% {
				stroke-dashoffset: -14;
			}
		}

		/*possibly a portrait mobi-fone*/
		@media screen and (max-width:500px) {

			#svgHolder {
				border-width: 2px;
			}

		}
	</style>
	<style id="mathStyles">
		/* (c) Aardvark Aaronson */

		frac {
			display: inline-grid;
			grid-template-columns: 1fr;
			grid-template-rows: 1fr 1fr;
			font-style: italic;
			font-size: 0.6em;
			vertical-align: middle;
			text-align: center;
		}

		num {
			border-bottom: 1px solid;
		}

		num::before {
			content: "\00a0\00a0";
		}

		num::after {
			content: "\00a0\00a0";
		}

		sup {
			font-size: 0.6em;
		}

		sub {
			font-size: 0.6em;
		}

		com {
			font-size: 0.5em;
		}

		com::before {
			content: "\00a0\00a0\00a0[";
		}

		com::after {
			content: "]";
		}

		whr {
			border-left: 1px solid;
			padding: 0.5em;
			margin-left: 1.25em;
			font-size: 0.7em;
			vertical-align: middle;
		}

		dd {
			margin-top: 15px;
		}
	</style>
</head>

<body>
	<div id="holder">

		<div id="svgHolder">

			<div id="gravLox">grav&middot;LoX</div>

			<div id="menu">
				<div style="padding:10px;">
					<input id="checkbox0" type="checkbox">
            <label id="label0" for="checkbox0">hide grid</label>
            <br>
            <input id="checkbox1" type="checkbox">
            <label id="label1" for="checkbox1">unmask mass</label>
        </div></div>
        
        <svg id="svgGrid"
         xmlns:xlink="http://www.w3.org/2000/svg"
         width="100%"
         viewbox="-50 -20 100 40"
         preserveAspectRatio="none"
        >
            <defs>
                
                <marker id="dot" refX="10" refY="10"
                 vector-effect="non-scaling-size"
                 markerUnits="userSpaceOnUse"
                 markerWidth="20"
                 markerHeight="20"
                 orient="auto"
                >
                    <circle cx="10" cy="10" r="0.4"
                     vector-effect="non-scaling-size"
                     fill="var(--dot-color)"
                     stroke="none"
                    ></circle>
                </marker>
        
                <g id="massdots"></g>
                
                <mask id="hole">
                    <rect
                    x="-50" y="-20"
                    width="100%" height="100%" fill="white" />
                    <use href="#massdots" />
                </mask>
                
            </defs>
            
            <circle id="loadball" cx="0" cy="0" r="1" transform="scale(0,0)"/>
            
            <g id=gridgroup mask="url(#hole)">
                <g id="xgridlines"></g>
                <g id="ygridlines"></g>
                <g id="axgridlines"></g>
            </g>
            
            <g id="massgroup">
                <g id="xmasslines"></g>
                <g id="ymasslines"></g>
                <g id="axmasslines"></g>
            </g>
            
            <g id="massouts"></g>
            
        </svg>

    </div>
        
    <div id="slideDiv" style="
        padding: 10px 0px 5px 0px;
        margin: 0;
    ">
        <input
         id="slide0"
         type="range"
         min="0"
         max="100"
         step="1"
         value="0"
        />
    </div>

    <div id="discussion">
        
        <div id="equation">
        <p>
            In this scene,
            <i>E</i>&nbsp;=&nbsp;m<i>c</i><sup>2</sup>&nbsp;
            and you probably recognize that the letter&nbsp;<i>c</i>
            in that equation
            refers to a <i>speed</i>; specifically,
            the speed of light.
        </p>
        
        <p>
            Now, you also know that the little number
            two:&nbsp;<sup>2</sup> means <i>squared</i>,
            which is the same as saying "times itself"
        </p>
        
        <p>
            We can re-write that equation as:
            <dd>
            <i>E</i> = m &middot; <i>c</i> &middot; <i>c</i>
            </dd>
        </p>
        
        <p>
            Normally when you think of speed, you think of it in terms
            of some <i>fraction</i> - that is,
            "some distance per time" as in:
            "miles per hour" or "meters per second" or "furlongs per
            fortnight" - whatever you want, <i>speed</i> is typically
            expressed as some quantity of distance being covered in
            some amount of time.
        </p>
        
        <p>
            That distance could be in any direction, in three dimensions;
            it doesn't <i>have</i> to be in only one dimension.
            Normally you drive straight ahead, but you could go
            left-and-right, forward-and-backwards, or even up-and-down
            if you're flying - so
            speed can be thought of as an amount of <i>space</i>
            being covered in a given <i>time</i>.
        </p>
        
        <p>
            We could say that:
            <dd>
            <i>speed</i> = <frac> <num>space</num> time </frac>
            </dd>
        </p>
        
        <p>
            Exactly how much space being covered, and passing time,
            the speed of light contains is not imporant -
            whatever the
            exact numbers are, we don't care for now; we just need
            to understand that the letter&nbsp;<i>c</i> refers to
            some amount of <frac><num>space</num>time</frac>
        </p>
        
        <p>
            Substituting that fraction for <i>c</i>
            in the equation, we should get:
            <dd>
                <i>E</i> = m &middot; <i>c</i> &middot; <i>c</i>
                <whr>
                <i>c</i> = <frac><num>space</num>time</frac>
                &Implies;
                </whr>
                <br><br>
                <i>E</i> = m
                &middot; <frac><num>space</num>time</frac>
                &middot; <frac><num>space</num>time</frac>
            </dd>
        </p>
        
        <p>
            With a little algebra, we can move one of those fractions
            to the other side:
            <dd>
                <i>E</i> = m
                &middot; <frac><num>space</num>time</frac>
                &middot; <frac><num>space</num>time</frac>
            </dd>
            <dd>
                <i>E</i>
                &middot;
                <frac><num>time</num>space</frac>
                =
                m
                &middot; <frac><num>space</num>time</frac>
                &middot; <frac><num>space</num>time</frac>
                &middot; <frac><num>time</num>space</frac>
                <com>
                 multiply both sides by
                 <frac><num>time</num>space</frac>
                </com>
            </dd>
            <dd>
                <i>E</i>
                &middot;
                <frac><num>time</num>space</frac>
                =
                m
                &middot; <frac><num>space</num>time</frac>
                &middot;
                <frac><num>
                    <s>space</s>
                    </num><s>time</s>
                </frac>
                &middot;
                <frac><num>
                    <s>time</s>
                    </num><s>space</s>
                </frac>
                <com> cancel out </com>
            </dd>
             <dd>
                <i>E</i>
                &middot;
                <frac><num>time</num>space</frac>
                =
                m
                &middot; <frac><num>space</num>time</frac>
            </dd>
        </p>

        <p>
            This is the relationship between energy <i>E</i>
            and mass <i>m</i>
            used for the computations
            in this scene.
            Energy and mass are proportional to eachother
            in this way:
        </p>
        
        <p>
            <dd>
                <frac>
                    <num>E &middot; time</num>
                    space
                </frac>
                &prop;
                <frac>
                    <num>m &middot; space</num>
                    time
                </frac>
            </dd>
        </p>
        
        </div>
        
        <hr>
        
        <div id="existing">
        <p>
            When you have a fraction, it means that one thing
            is <i>divided up</i>
            over some other thing - if you have, say $80, and
            you 'divided it up' among ten people, what that
            means is, you're 'spreading out' the eighty dollars
            over the ten people.
        </p>
        
        <p>
            If a farm has 30,000 stalks of corn 'per acre' that means
            the stalks are spread out over the acres.
        </p>
        
        <p>
            What we mean by
            <frac><num>m &middot; space</num> time</frac>
            is that some amount of mass and space is evenly distributed
            over <i>time.</i>
        </p>
        
        <p>
            Saying that something is 'evenly distributed over time'
            just means that the thing <i>exists.</i>
        </p>
        
        <p>
            If an object did not persist for any amount of time,
            then it wouldn't exist by the standards of what
            the term 'exist' typically means.  That an object
            has length and width and depth is only applicable
            if it also has <i>persistence.</i>
        </p>
        
        <p>
            Your company leases a storage unit - the unit is
            rented based on its dimensions, length, width, height,
            but also by its duration, that is, the time of
            the lease. If you have a six-month lease on a storage
            unit, sure your company has access to
            8&times;10&times;12 feets
            of space, but after that six months expires, it's
            no longer applicable to anything your company does.
        </p>
        
        <p>
            Similarly, if there weren't any <i>dimension</i>
            for an object to exist in, then it wouldn't exist.
            If you only had two dimensions, then 'spheres'
            would only exist as whatever circle happens to
            be intersecting the plane of your existence.
            There needs to be some space for mass to occupy.
            Your company better rent a storage unit with
            enough dimensions to hold whatever you need to store.
        </p>
        
        <p>
            By saying
            <frac><num>m &middot; space</num>time</frac>
            we mean that there is some stuff, <i>mass</i>,
            and it occupies some dimension, <i>space</i>,
            and all of that is evenly distributed over
            <i>time</i> - it all persists.
        </p>
        
        </div>
        
        <div id="devouring">
        <p>
            On the other side of the equation, we have
            <frac><num>E &middot; time</num>space</frac>
            by which we mean that there is some amount
            of energy and some time, and all of that is
            evenly distributed throughout space. Both
            energy and time are spread out into the space.
        </p>
        
        <p>
            In this scene, the universe has had a grid
            laid out over it, in order for you to visualize
            it more easily - each section of the grid
            contains some amount of energy as well as some time.
        </p>
        
        <p>
            Scrolling over the scene causes specific locations
            to begin <i>consuming</i> the universe around them.
            [Scroll left-to-right over the scene, or drag the
            slider - click in the slider bar to animate.]
        </p>
        
        <p>
            These locations devour the surrounding grid
            and convert that into an object; an object
            that occupies the dimensions that were converted
            from the space around them, and which
            persists throughout the time which was also
            pulled through from the grid.
        </p>
        
        <p>
            That is to say, when you start scrolling,
            things start moving from one side of the
            equation to the other.
            <dd>
                <i>E</i> &middot; <frac><num>time</num>space</frac>
                &nbsp;
                &rrarr;
                &#x21f6;
                &nbsp;
                m &middot; <frac><num>space</num>time</frac>
            </dd>
            <br>
            Initially, nothing exists on the <i>mass</i>
            side of the equation.
            When you start scrolling,
            objects get formed; those objects need some dimensions
            to occupy.  The dimensions they occupy are the ones
            sucked through from the space on the other side of the
            equation. The objects and the dimensions need to persist
            for some time; the time they exist during is the time
            from the other side of the equation.
        </p>
        
        <p>
            Again, the masses ingest the grid, and turn
            it into more mass - this consumption causes
            the grid to warp.
            Eventually, the distortion forms a very strong
            and noticable connection between the
            centers of each object.
        </p>
        </div>
        
        <div id="denial">
        <p>
            The grid does not warp to accomodate the mass;
            neither does the presence of the mass cause
            space to warp.
        </p>
        
        <p>
            The masses <i>are</i> the wrapping of space
            up into a ball.
            Energy and time-space are sucked through to
            the opposite side of the equation, and that
            forms an object.
        </p>
        
        <p>
            The 'attraction' the objects have towards
            eachother's center <i>is</i> the distortion
            that occurs as the objects swallow the
            surrounding grid-space.
        </p>
        </div>  <hr>
        
        <div id="fabric">
        <p>
            <i>If</i> space-time is a 'fabric', imagine that
            fabric laid out on a table.  Then, <i>pinch</i>
            the fabric somewhere in the middle and start
            crumpling it up into a ball in your hand.
            <br><br>
            Eventually, the fabric will be distorted and
            wrinkled up, and there will appear to be a ball
            in the middle of it.  There <i>isn't</i> a ball,
            or an object, or a mass, or anything - it's just
            the fabric being crunched up.  The fabric isn't
            distorting because of some object that's inside
            it - the object IS the distortion of the fabric.
        </p>
        
        <p>
            Now imagine that someonelse <i>also</i> starts
            pinching the fabric in a different place.
            [This is a big piece of fabric - imagine it's
            a large bed sheet, and it's spread out on
	    a hard wooden floor.]
            <br><br>
            You both pinch the sheet at a different place
            somewhere in the
            middle and start crumpling it up into a ball.
            After a little while, your hands are
            going to start getting closer to eachother.
            <br><br>
            That is, since you're both pulling the sheet
            into your hands, the part of the sheet that's
            between your two hands is getting pulled into
            both of your hands at once; unless you <i>tear</i>
            the sheet [don't tear the sheet! you'll get
            in trouble], your hands will start getting
            closer to eachother until the two wads of
            fabric you're both crunching up touch one another,
            and become a single big ball.
            
            If we're both eating the same string of spaghetti,
            from opposite sides, either the spaghetti is going
            to snap, or we're going to kiss.
            <br><br>
            
            Again, there is no force pulling the two things
            together - the 'pulling force' is the wadding
            up of the sheet into a ball.  It's the
            drawing up of the sheet into your hand
            that appears to draw the two things together.
            <br><br>
            <i>And</i> there aren't 'things' - there just
            appear to be things because the sheet is
            crunched up in different places.
        </p>
        
        <p>
            [Note that this animation does not show the
            part where the masses start getting closer
            to eachother - though it could, ofcourse, do
            that from the same calculation; it's simply
            intended to emphasize, for now, the
            grid-becoming-mass portion of what's happening.
            <br><br>
            You should also be able to see that the masses
            are 'attracted' in <i>many</i> directions
            at once - along every different line in the
            grid, in fact - it's just that a preponderance
            of grid-lines has been concentrated between
            the 'centers of mass' of each object.]
        </p>
        </div>  <hr>
        
        <div id="boxing">
        
        <p>
            Make a box ...
            <p style="width:100%;text-align:center;">
            <img src="sketchBox.svg"
            style="width:200px;">
            </p>
            How's that? Does that look like a box?
	    Close enough?
	    <br><br>
	    It's a box; it's got all the parts,
            length, width, height - it even exists for some
            period of time. It contains all of the dimensions
            that a box usually has.
        </p>
        
        <p>
            Now, <i>conceptually,</i> collapse the box,
            in one direction; squoosh it down into a square ...
            <p style="width:100%;text-align:center;">
            <img src="collapsingBox.svg"
            style="width:200px;">
            </p>
            Alright? It <i>still has</i> all of its dimensions.
            We are just going to use this plane as a
            representation of the dimensional space of
            the box - we're going to imagine that
            one of the box's dimensions has been flattened
            down so far that the box now looks like a square.
            All of the dimension, and space, and everything
            that was originally inside the box is still there;
            we're simply using a flat plane to represent
            the whole box.
        </p>
        
        <p>
            Now do that same thing with <i>another box</i>;
            a different box that has been divided up using
            a grid ...
            <p style="width:100%;text-align:center;">
            <img src="collapsingGrid.svg"
            style="width:200px;">
            </p>
            The length, width, height, depth, time,
            everything is still in there, we're just
            collapsing one of the directions so that we
            can use a square to represent the entire box.
        </p>
        
        <p>
            At this point, we have two different
            <i>planes of existence.</i> We have two
            squares, or planes, that are representative
            of fully-dimensional realms.
        </p>
        
        <p>
            Take the two planes, and <i>intersect them</i>...
            <p style="width:100%;text-align:center;">
            <img src="intersectionPlanes.svg"
            style="width:300px;">
            </p>
            That is, effectually, what is happening in
            this scene.
            <br><br>
            There are two separate <i>realms of existence</i>.
            
            One of them is the 'mass realm', the
            <frac><num>m &middot; space</num> time </frac>
            side of the equation. The other is the
            'energy realm' or the
            <frac><num>E &middot; time</num> space </frac>
            side of the equation.
            <br><br>
            
            Initially, the mass-realm is completely empty;
            there is nothing in it - no length or
            width or height or mass.  At first, the mass-realm
            doesn't even <i>exist</i> because it doesn't
            even have the time it would need in order to exist.
            <br><br>
            
            In the beginning of the scene, the <i>energy-realm</i>
            exists. It has a grid laid out over it;
            time and energy are spread throughout the space.
            That particular realm is teaming with energy
            and time, and all of that is contained in
            dimensions.  Here, we've visualized that as
            a grided-plane.
            <br><br>
            
            As the grid gets ingested, things begin to
            'transfer' into the mass-realm.
            Things from the <i>Energy</i> side of the
            equation begin projecting into the
            mass-realm...
            <p style="width:100%;text-align:center;">
            <img src="intersectionMass.svg"
            style="width:300px;">
            </p>
            Remember that the mass side of the equation
            does not exist at first; as things
            move from one side of the equation,
            they <i>construct</i> the other.
            The energy and grid-lines get projected
            through <i>as mass</i>; the dimensions
            transfer through to create the length
            and width and height needed to hold the
            mass; the time gets transposed into
            the time needed for everything to persist.
            <br><br>
            This happens with every mass in the scene.
        </p>
        
        <p>
            It would either be confusing or impractical
            to attempt to show two different three-dimensional
            realities intersecting eachother at right angles,
            which is why they were reduced to planes for
            this example.
        </p>
        </div>  <hr>
        
        <div id="threading">
            
            It might be a little easier to see what a single line
            itself is doing if the other grid-lines are removed.
            <br><br>
            <div id="toggleDiv" style="
                width: 100%;
                text-align: center;
                font-style: italic;
                user-select: none;
            ">~~~~~</div>
            <br>
            
            Again, the masses are not masses - they are conceptual
            <i>locations</i>, indicated by coordinates, that consume
            the grid in all directions, then spit it back out
            into the mass-realm. It's more like the grid-lines are
            threads that get pulled in through a pin hole, and make
            little thread-loops.
            <br><br>
            
            With the grid-lines turned off, it's also easier to
            see that the loops <i>change shape</i> through
            the progression.  When viewed initially, it seems
            like the masses have a 'pattern' on them, and that
            they simply grow larger. Infact, your view is not
            'zooming in' on the mass objects at all; more and
            more lines are getting drawn inside the mass-area
            each time, prducing more and more of the apparent
            field-loop pattern.
            <br><br>
            
            [You can double-click the scene, or
            <span id="toggleMenuDiv"
             style="
                font-variant-caps: all-small-caps;
                font-style: italic;
                user-select: none;
             "
            >click here</span>
            to toggle a menu that allows for adjusting what
            gets displayed. If you want to, you can also
            <span id="toggleAnilineDiv"
             style="
                font-variant-caps: all-small-caps;
                font-style: italic;
                user-select: none;
             "
            >animate the line</span>, which might also help.]
            <br><br>
            
            A <i>mask</i> has been placed over each area where the
            mass-lines appear in order to
            cover the lines from the grid and make the view
            less cluttered.
            Unmasking the masses will allow you to see that
            all the grid-lines <i>are</i> still being drawn
            on the grid-plane.
            <br><br>
            
            In this configuration, the mass-lines give the
            impression that each mass has a <i>pattern</i>
            drawn on it, and that progressing through the
            animation enlarges your view of that pattern.
            <br><br>
            
            <div id="recalcDiv"
             style="
                width:100%;
                text-align:center;
                font-style: italic;
                user-select:none;
              "
            >~~~~~</div>
            <br>
            
            If we recalculate the scene with only one mass,
            and increase the universal constant, it will be
            more obvious that the number of lines within the
            mass-area increases as more grid-lines get sucked in,
            and that the lines increase in size, as opposed
            to being simply a pattern that gets magnified.
            <br><br>

            
            You can recalculate with some new randomly placed mass
            locations aswell, if you don't mind sitting through
            the recalculation.
            
        </div>  <hr>
        
        <div id="constancy">
            
            <p>
            Remember back when we said that we were not going to
            be concerned <i>at the time</i> with exactly
            what values were contained in the
            <i>E</i>&nbsp;=&nbsp;m<i>c</i><sup>2</sup>&nbsp;
            equation? Well, now we've finally reached the point
            where we actually <i>still</i> don't care!
            </p>
            
            <p>
            The calculation in the scene werks not by knowing
            how far light moves in a second but by using
            the <i>speed of mass.</i> And it's not even that;
            it's not even the <i>speed</i> of mass - it's the
            <i>relative rate</i> of the speed of mass
            compared to the speed of light.
            </p>
            
            <p>
            For this equation, it doesn't matter what the
            speed of light is, it only matters what
            <i>percent</i> of the speed of light the
            speed of mass is. Maybe mass only expands at
            ten percent the speed of light, or maybe only
            one percent - or maybe a <i>much, much smaller</i>
            percent; it doesn't matter what the actual value
            is, just the relative percent.
            </p>
            
            <p>
            This 'universal constant' of the <i>speed of mass</i>
            can be adjusted - which was done, for instance,
            to allow you to more clearly see the expansion of
            mass in the scene.
            </p>
            
            <p>
            Mass-locations begin consuming the grid at the
            rate of the 'inverse square'. The supposed masses
            are simply coordinate designations; the grid-points
            are also nothing more than coordinates.
            That is to say, there is no 'm<sub>1</sub>'
            or 'm<sub>2</sub>' or any mass involved in the
            computation - there is no 'big G' or gravitational
            constant. The coordinate locations of the masses
            begin eating up the grid at the rate of
            <frac><num>1</num>2</frac>a<i>t</i><sup>2</sup>
            and the mass-lines begin projecting into the
            mass-realm at some fraction of that rate.
            [This allows you to drop the <frac><num>1</num>2</frac>
            and just use the consumption rate of a<i>t</i><sup>2</sup>
            for the grid and %a<i>t</i><sup>2</sup> for the
            mass-lines.]
            </p>
            
        </div>  <hr>
        
        <div id="emergency">
            
            <p>
            The grid does not warp to accomodate the mass.
            The masses do not distort the grid with their presence.
            The objects are not drawn towards eachother.
            There is no gravity.
            There are no objects.
            </p>
            
        </div>

        <p id="sig" style="text-align:right;width:100%"><i>~queviva</i></p>
        
        <p class="addendum"></p>
        
    </div>
  
</div>
</body>

<script id="gravscript">

////////////////////////////////////////////////////////////{
// licensed from Aardvark Aaronson, November 2021          //
// MCMLXXXVIII                                             //
////////////////////////////////////////////////////////////}

// expiration date {
new Date() < new Date('2023-10-13') &&

((dset = document.currentScript.dataset) =>

  document.addEventListener('DOMContentLoaded', () => {
      
//}
    
    
        ////////////////////////////////////////////////////////////
        
        // preferences {
        
        const appName = 'grav&middot\;LoX';
    
        let bigSmall = 2;
        
        let size = [8,  2,   2][bigSmall];
        let xdim = [35, 50, 70][bigSmall];
        let ydim = [20, 22, 40][bigSmall];
        
        const numSteps = 100;
        const aniStall = 10;
        const valScale = 0.8;
        const useDots = false;
        const aniMass = false;
        
        let speedOfMass = 0.001; // in pixels-per-timestep
        
        const cssProps = {
            'line-width' : 0.4,
            'line-color' : 'hsla(48,100%,88%,1.0)',
            'axis-width' : 0.6,
            'axis-color' : 'rgba(255,165,0,1.0)',
            'ani-width'  : 1.2,
            'ani-color'  : '#c30',
            'mass-color' : '#000',
            'mass-stroke' : 'rgba(255,165,0,1.0)',
            'mass-stroke-width' : 3,
            'mass-line-width' : 0.8,
            'mass-line-color' : 'rgba(255,165,0,1.0)',
            'load-ball-color' : 'rgba(255,165,0,1.0)',
            'load-ball-stroke' : 'rgba(204,119,0,1.0)',
        };
        
        const massList = [
            
           //[int x, int y, int first_step]
            
             [-24,  -8,  0]
            ,[ 26,   8, 20]
            ,[-42,   3, 85]
            
            // equilateral {
            //[ 0, -12, 5, 0],
            //[-12,  4, 5, 0],
            //[ 12,  4, 5, 0]
            // }
            
            //[0, 0, 0]
            
        ];
        
        const menuMsgs = {
            hide: 'hide grid',
            mask: 'unmask masses'
        };
        
        const toggleMsgs = {
            turnon   : '~~ click to show lines ~~',
            turnoff  : '~~ click to hide lines ~~',
            disabled : '~~~~~'
        };
        
        const recalcMsgs = {
            onemass  : '~~ click to recalc ~~',
            randmass : '~~ calc random masses ~~',
            disabled : '~~~~~'
        };
    
        //}
    
        // references {
        
        let count = 0;
    
        // svg elements {
        const NS = 'http://www.w3.org/2000/svg';
        const svgHolder = document.getElementById('svgHolder');
        const xgridlines = document.getElementById('xgridlines');
        const ygridlines = document.getElementById('ygridlines');
        const axgridlines = document.getElementById('axgridlines');
        const axmasslines = document.getElementById('axmasslines');
        const loadball = document.getElementById('loadball');
        const gridgroup = document.getElementById('gridgroup');
        const massgroup = document.getElementById('massgroup');
        const massdots = document.getElementById('massdots');
        const massouts = document.getElementById('massouts');
        //}
        
        // slider input elements {
        const slideDiv = document.getElementById('slideDiv' );
        const slide0 = document.getElementById('slide0' );
        slide0.disabled = true;
        //}
    
        // toggle divs and captions {
        const toggleDiv = document.getElementById('toggleDiv');
        toggleDiv.innerHTML = toggleMsgs.disabled;
        const recalcDiv = document.getElementById('recalcDiv');
        recalcDiv.innerHTML = recalcMsgs.disabled;
        recalcDiv.old = recalcMsgs.onemass;
        //}
        
        // menu elements and configuration {
        const menu = document.getElementById('menu');
        const menuH = window.getComputedStyle(menu).height;
        menu.style.visibility = 'visible';
        menu.style.height = '0px';
        const checkbox0 = document.getElementById('checkbox0');
        const label0 = document.getElementById('label0');
        label0.innerText = menuMsgs.hide;
        const checkbox1 = document.getElementById('checkbox1');
        const label1 = document.getElementById('label1');
        label1.innerText = menuMsgs.mask;
        //}
        
        //}
        
        // global arrays {
        
        let xPts = (new Array(1 + (2 * ydim))).fill(0);
        let yPts = [];
        
        let xlineObjs = [];
        let ylineObjs = [];
        
        let masses = [];
        let merms = [];
        
        //}
    
        // utils {
        
        const getDist = (A, B) => Math.sqrt( //{
            Math.pow(A.x - B.x, 2) +
            Math.pow(A.y - B.y, 2) //+
          //Math.pow(A.z - B.z, 2) the mythical third dimension
        ); //}

        const randFrom = (...A) => // {
            ~~(Math.min(...A) + Math.random() * (Math.max(...A) - Math.min(...A)));
        //}
        
        const randInt = A => ~~(Math.random() * A);

        //const xBetweenYandZ = (x, y, z) => (x-y) * (x-z) < 0;
        
        //const gate = (...v) => v.sort((a, b) => a - b)[1];
        
        //}
            
        ////////////////////////////////////////////////////////////
        
        // point object {
        
        function Point (x, y) {
    
            this.x = x;
            this.y = y;
            
            this.thetas = [];
            this.acc = [];
            
            this.svgMem = new Array(numSteps + 1);
            this.svgMem[0] = 'L' + x +' '+ y;
            
            this.threshold = Infinity;
            
            this.transPoint = {
                dex: null,
                x: null,
                y: null,
                cos: null,
                sin: null
            };
    
        }
        
        Point.prototype.addMass = function (m, step) {
        
            let dist = getDist(m, this);
        
            if (dist === 0 && m.first === step) {
                this.svgMem.fill('L' + this.x +' '+ this.y);
                this.acc[m.dex] = 0;
                this.thetas[m.dex] = 0;
                return;
            }
        
            this.acc[m.dex] = 1 / (dist * dist);
        
            this.thetas[m.dex] = Math.atan2(
                this.y - m.y,
                this.x - m.x
            );
            
        };
        
        Point.prototype.recalc = function (step = 0) {
            
            // if this step is already calculated skip out
            if (this.svgMem[step]) { return; }
            
            // if this point has already transitioned realms ...
            if (step > this.threshold) {
                
                // compute the distance to travel
                let D = speedOfMass *
                       (step - this.threshold) *
                       (step - this.threshold);
                
                // update the mass-realm coords
                this.x = this.transPoint.x + (this.transPoint.cos * D);
                this.y = this.transPoint.y + (this.transPoint.sin * D);
                
                // set the svg for this step
                this.svgMem[step] = 'L' + this.x +' '+ this.y;
                
                // and finish
                return;
                
            }
            
            // otherwise, scale the change in time
            let dT = step * valScale;
            
            // begin amassing change in position
            let dx = 0;
            let dy = 0;
    
            // loop through every emerged mass
            for (let m of merms) {
                
                // figure out the angle to that mass at this step
                let theta = Math.atan2(
                    m.y - this.y,
                    m.x - this.x
                );
                
                // adjust the change in time
                let adj = (step - m.first) * valScale;
                
                // compute the distance to travel
                let D = this.acc[m.dex] * adj * adj;
                
                // compound the position deltas
                dx += D * Math.cos(theta) || 0;
                dy += D * Math.sin(theta) || 0;
                
            }
    
            // update the coords
            this.x += dx;
            this.y += dy;
            
            // set the svg for this step
            this.svgMem[step] = 'L' + this.x.toFixed(3) +
                                ' ' + this.y.toFixed(3);
            
            // loop through all emerged masses ...
            for (let m of merms) {
                
                // if this point has transitioned realms ...
                if (Math.sqrt(dx*dx + dy*dy) >= getDist(m, this)) {
                    
                    // set the threshold to this step
                    this.threshold = step;
                    
                    // remember the transition-point info
                    this.transPoint = {
                        dex: m.dex,
                        x: m.x,
                        y: m.y,
                        cos: Math.cos(this.thetas[m.dex]),
                        sin: Math.sin(this.thetas[m.dex]),
                        svg: 'L' + m.x +' '+ m.y
                    };
                    
                    // overwrite the coords for this step
                    this.svgMem[step] = 'L' + m.x +' '+ m.y;
                    
                    // skip out
                    break;
                    
                }
            }
            
        };
        
        //}
        
        // line object {
        
        function Line (gridobj, massobj, pts) {
            
            this.gridobj = gridobj;
            this.massobj = massobj;
            
            this.pts = pts;
            this.gridpaths = [];
            this.masspaths = new Array(numSteps + 1).fill('');
            
        }
        
        Line.prototype.genPath = function (step = 0) {
            
            // start grid path with zer0-ith point
            let tmpGD = this.pts[0].svgMem[step].replace('L', 'M');
            
            // loop through all the remaining points
            for (let i = 1, j = this.pts.length; i < j; i++) {
                
                // if the point is past its threshold ...
                if (step > this.pts[i].threshold) {
                    
                    // use the transition point
                    tmpGD += this.pts[i].transPoint.svg;
                    
                } else { // otherwise ...
                
                    // use the coords of this point
                    tmpGD += this.pts[i].svgMem[step];
                    
                }
                
                // DEBUGG - remove this memory point
                this.pts[i].svgMem[step-1] = null;
                
            }
            
            // set that path to the grid-path for this step
            this.gridpaths[step] = tmpGD;
            
            // get all the mass points from this line
            let massPts = this.pts.filter(p => step > p.threshold);
            
            // loop through each mass
            masses.forEach(m => {
                
                // start a mass line at that mass location
                let tmpMD = 'M' + m.x +' '+ m.y;
                
                // get all the points for just this mass
                massPts.filter(p => p.transPoint.dex === m.dex)
                .forEach(mp => {
                    
                    // add that point to this path
                    tmpMD += mp.svgMem[step];
                    
                });
                
                // add this mass-line to the mass-lines for this step
                this.masspaths[step] += tmpMD + 'Z';
                
            });
            
        };
        
        Line.prototype.drawPath = function (step = 0) {
            this.gridobj.setAttribute('d',this.gridpaths[step] || 'M0 0Z');
            this.massobj.setAttribute('d',this.masspaths[step] || 'M0 0Z');
        };
        
        //}
        
        // mass object {
        
        function Mass (dex, x, y, first = 0) {
            
            this.x = x;
            this.y = y;
            
            this.dex = dex;
            this.first = first;
            
            this.rads = [];
            
            ['dot', 'out'].forEach(t => {
                
                this[t] = document.createElementNS(NS, 'circle');
                
                Object.entries({
                    cx: x, cy: y, r: 0
                }).forEach(a => this[t].setAttribute(a[0], a[1]));
                
                this[t].classList.add('mass'+t);
                
                window['mass' + t +'s'].appendChild(this[t])
                
            });
    
        }
    
        Mass.prototype.genPath = function (step = 0) {
            
            // compute adjusted radius for this step
            let adj = step < this.first ? 0 :
                     (step - this.first - 2) < 0 ? 0 :
                     (step - this.first - 2);
                      
            this.rads[step] = speedOfMass* adj * adj;
            
        };
        
        Mass.prototype.drawPath = function (step = 0) {
            
            this.dot.setAttribute('r', this.rads[step]);
            this.out.setAttribute('r',
                this.rads[step] - 0.2 < 0 ? 0 : this.rads[step] - 0.2
            );
            
        };
        
        //}
        
        // animation object {
        const aniMaker = new function () {
            
            this.dir = 0;
            this.stall = aniStall;
            this.isLooping = false;
            
            this.anim = () => {
                
                // if it still needs to run ...
                if (
                    (count < 100 && count > 0)
                    ||
                    (count === 0 && this.dir === 1)
                    ||
                    (count === 100 && this.dir === -1)
                ) {
                    
                    // call the increment
                    incCount(this.dir);
                    
                    // adjust the slider
                    slide0.value = count;
                    
                    // redraw the scene
                    update(count);
        
                    // recall the loop
                    this.isLooping = setTimeout(this.anim, this.stall);
        
                } else { // otherwise ...
                
                    // stop the loop
                    this.stop();
        
                }
            };
            
            this.start = (dir) => {
                this.dir = dir;
                this.anim();
            };
            
            this.stop = () => {
                clearTimeout(this.isLooping);
                this.isLooping = false;
            };
            
        };
        //}
        
        // lizzer object {
        const Liz = {
            
            lizzers : [
                
            // increment on scroll {
            [svgHolder, 'wheel', e => {
        
                // stop the browser from going back-button-ward
                e.preventDefault();
        
                // if the scroll was big enough ...
                if (Math.abs(e.deltaX) > 5) {
        
                    // if the animation is running ...
                    if (aniMaker.isLooping !== false) {
        
                        // stop the loop
                        aniMaker.stop();
        
                    }
        
                    // increment the count
                    incCount(Math.sign(e.deltaX));
        
                    // adjust slider
                    slide0.value = count;
        
                    update(count);
        
                }
        
            }],
            // }
        
            // increment on slide {
            [slide0, 'input', e => {
        
                e.stopPropagation();
        
                // if animation is running ...
                if (aniMaker.isLooping !== false) {
        
                    // stop the loop
                    aniMaker.stop();
        
                }
        
                // increment by the value
                count = parseInt(slide0.value, 10),
                    update(count);
        
            }],
            //}
        
            // animate on slider div click {
            [slideDiv, 'click', e => {
        
                // get the direction from the click
                let dir = [1, -1][
                    (100 *
                        (e.clientX - slideDiv.offsetLeft - holder.offsetLeft) /
                        slideDiv.offsetWidth >
                        slide0.value) ?
                    0 : 1
                ];
        
                // if the animation is already running ...
                if (aniMaker.isLooping !== false) {
        
                    // and running in the OPPOSITE direction ...
                    if (dir !== aniMaker.dir) {
        
                        // change the direction
                        aniMaker.dir = dir;
        
                    }
                    else { // otherwise it is running in the same dir ...
        
                        // so, stop the loop
                        aniMaker.stop()
        
                    }
        
                }
                else { // if the animation is not running ...
        
                    // start the animation
                    aniMaker.start(dir);
        
                }
        
            }],
            //}
        
            // swallow clicks directly on thumb {
            [slide0, 'click', e => {
                e.stopPropagation();
                e.cancelBubble = true;
            }],
            //}
        
            // swallow double clicks on menu {
            [menu, 'dblclick', e => {
                e.stopPropagation();
                e.cancelBubble = true;
            }],
            //}
            
            // toggle lines on div click {
            [toggleDiv, 'click', e => {
                
                if (toggleDiv.innerHTML === toggleMsgs.turnoff) {
                    
                    toggleDiv.innerHTML = toggleMsgs.turnon;
                    checkbox0.checked = true;
                    toggleGrid();
                    checkbox1.checked = true;
                    toggleMask();
                    
                } else {
                    
                    toggleDiv.innerHTML = toggleMsgs.turnoff;
                    checkbox0.checked = false;
                    toggleGrid();
                    checkbox1.checked = false;
                    toggleMask();
                    
                }
                
            }],
            //}
        
            // reset masses on div click {
            [recalcDiv, 'click', e => {
                
                if (recalcDiv.innerHTML === recalcMsgs.onemass) {
                    
                    // this is one big mass with fast growth
                    resetMasses([[-24, -8, 0]], 0.01);
                    recalcDiv.old = recalcMsgs.randmass;
                    
                } else {
                    
                    resetMasses([
                        
                        // place three in general areas
                        [randFrom(-30,-20), randInt(10), 0],
                        [randFrom(20,35), randInt(-10), randFrom(15,25)],
                        [randFrom(-45,-40), randFrom(-10,3), 82]
                        
                    ], 0.001); // use slower universal constant
                    
                    recalcDiv.old = recalcMsgs.onemass;
                    
                }
                
            }],
            //}
            
            // toggle menu on scene double-click {
            [svgHolder, 'dblclick', e => {
        
                e.preventDefault();
                
                toggleMenu();
                

            }],
            //}
        
            // hide lines on menu checkbox {
            [checkbox0, 'change', e => {
                toggleGrid();
            }],
            //}
            
            // unmask masses on menu checkbox {
            [checkbox1, 'change', e => {
                toggleMask();
            }],
            //}
            
            // toggle menu from dialogue {
            [document.getElementById('toggleMenuDiv'), 'click', e => {
                toggleMenu();
            }],
            //}
            
            // toggle animation in discussion {
            [document.getElementById('toggleAnilineDiv'), 'click', e => {
                toggleAniline();
            }]
            //}
            
            ],
            
            add : function (L = this.lizzers, v = 0) {
                for (const [x, y, z] of L) {
                    y.split(',').forEach(e =>
                        x[['add','remove'][v] + 'EventListener'
                        ](e, z, { passive: false })
                    );
                }
            },
            
            remove : function () { this.add(this.lizzers, 1); }
            
        };
        //}
        
        ////////////////////////////////////////////////////////////
        
        // menu toggler {
        function toggleMenu () {
            menu.style.height = menu.style.height === '0px' ? menuH : '0px';
        }
        //}
        
        // grid-line toggler {
        function toggleGrid () {
        
            if (checkbox0.checked) {
                
                massouts.style.display = 'none';
        
                [...xlineObjs, ...ylineObjs].forEach(L => {
                    if (!L.gridobj.classList.contains('axisline')) {
                        L.gridobj.style.display = 'none';
                        L.massobj.style.display = 'none';
                    }
                });
        
        
            } else {
                
                massouts.style.display = 'block';
        
                [...xlineObjs, ...ylineObjs].forEach(L => {
                    if (!L.gridobj.classList.contains('axisline')) {
                        L.gridobj.style.display = 'block';
                        L.massobj.style.display = 'block';
                    }
                });
            }
        }
        //}
        
        // mass mask toggler {
        function toggleMask () {
        
            if (checkbox1.checked) {
        
                massdots.childNodes.forEach(m => m.style.fill = '#fff');
        
            } else {
        
                massdots.childNodes.forEach(m => m.style.fill = '#000');
            }
        }
        //}
        
        // line animation toggler {
        function toggleAniline () {
            
            let tmpL = [
                axgridlines.childNodes[0],
                axgridlines.childNodes[1],
                axmasslines.childNodes[0],
                axmasslines.childNodes[1]
            ];
            
            if (axgridlines.childNodes[0].classList.contains('aniline')) {
                
                tmpL.forEach(L => {
                    L.classList.remove('aniline');
                    L.style.strokeWidth = 'var(--axis-width)';
                    L.style.stroke = 'var(--axis-color)';
                });
            
            } else {
                
                tmpL.forEach(L => {
                    L.classList.add('aniline');
                    L.style.strokeWidth = 'var(--ani-width)';
                    L.style.stroke = 'var(--ani-color)';
                });
                
            }
    
        }
        //}
        
        ////////////////////////////////////////////////////////////
        
        // mass resetter {
        function resetMasses (mlist, uc) {
                    
                // stop animation if running {
                if (aniMaker.isLooping !== false) {
        
                    // stop the loop
                    aniMaker.stop();
        
                }
                //}
        
                // alter the universal constant {
                speedOfMass = uc || speedOfMass;
                //}
                
                // set the slider to zer0 {
                slide0.value = 0;
                //}
        
                // remove all svg lines and masses {
                [
                    xgridlines, ygridlines, axgridlines,
                    xmasslines, ymasslines, axmasslines,
                    massdots, massouts,
        
                ].forEach(g => {
        
                    while (g.firstChild) {
                        g.removeChild(g.firstChild);
                    }
        
                });
                //}
                
                // clear out the arrays {
                xlineObjs = [];
                ylineObjs = [];
                merms = [];
                xPts = (new Array(1 + (2 * ydim))).fill(0);
                yPts = [];
                //}
        
                // restart the universe ...
                init(mlist);
        
        }
        //}
        
        // scene updater {
        function update(step) {
            
            // draw the masses
            masses.forEach(M => M.drawPath(step));
            
            // draw the x-lines
            xlineObjs.forEach(L => L.drawPath(step));
    
            // draw the y-lines
            ylineObjs.forEach(L => L.drawPath(step));
    
        }
        //}
        
        // count incrementer {
        function incCount(val) {
            
            // make a copy of the count
            let c = count;
            
            // increment the count gated between zero and a hundred
            count = [0, count + val, 100].sort((a, b) => a - b)[1];
            
            // if the count has actually changed ...
            if (c !== count) {
                
                // redraw the scene
                update();
                
            }
        
        }
        //}
        
        // mass and point loader {
        function massPointLoader () {
            
            // if it still needs to load ...
            if (count < numSteps + 1) {
                
                // recalc the radius for all masses
                masses.forEach(M => M.genPath(count));
                
                // if any masses emerge at this step ...
                masses.filter(m => m.first === count).forEach(m => {
                    
                    // add them to every point
                    for (let AP of xPts) { for (let p of AP) {
                        p.addMass(m, count);
                    }}
                    
                    // update the emerged masses list
                    merms = masses.filter(m => m.first <= count);
                
                });
                
                // recalc all the points
                for (let AP of xPts) { for (let p of AP) {
                    p.recalc(count);
                }}
                
                // increment the load count
                count++;
                
                // display percent complete
                gravLox.innerHTML = (100*count/numSteps).toFixed(0) + '%';
                
                // scale the loading mass-energy
                let per = count / (numSteps + 1);
                
                // scale the grid as a vizualoazer
                gridgroup.setAttribute(
                    'transform',
                    'scale(' + per + ','+ per +')'
                );
                
                // fade the grid as a vizualizer
                gridgroup.style.opacity = count / numSteps;
                
                // total recall
                window.requestAnimationFrame(massPointLoader);
                
            } else { // otherwise done so ...
            
                // reset the load count to zero
                count = 0;
                
                // unscale the grid area
                gridgroup.setAttribute('transform', 'scale(1, 1)');
                
                // opacify the grid area
                gridgroup.style.opacity = '1.0';
                
                // free some memory here
                xPts = [];
                yPts = [];
                
                // call the line generating loader
                window.requestAnimationFrame(lineLoader);
                
            }
            
        }
        //}
        
        // line loader {
        function lineLoader () {
            
            // if it still needs to load ...
            if (count < numSteps + 1) {
                
                // generate the paths for all the lines
                xlineObjs.forEach(L => L.genPath(count));
                ylineObjs.forEach(L => L.genPath(count));
                
                // increment the load count
                count++;
                
                // scale the loading ball mass-energy
                let per = count / (numSteps + 1);
                
                loadball.setAttribute(
                    'transform',
                    'scale(' + (1 - per) * 55 + ','+ (1 - per) * 55 +')'
                );
                
                loadball.style.opacity = 1 - per * per;
                
                // display percent complete
                gravLox.innerHTML = (101 - 101 * per).toFixed(0) + '%';
                
                // total recall
                window.requestAnimationFrame(lineLoader);
                
            } else { // done with lines ...
            
                // reset the count
                count = 0;
                
                // call the enabler
                enable();
                
            }
                
        }
            
        //}
        
        // enable your dysfunction {
        function enable () {
        
            // hide the loading ball
            loadball.style.display = 'none';
        
            // reset the gravlox logo
            gravLox.innerHTML = appName;
        
            // load the listeners
            Liz.add();
        
            // enable the slider
            slide0.disabled = false;
            
            // ensure mass outlines are on
            massouts.style.display = 'block';
            
            // show the toggle msg
            toggleDiv.innerHTML = toggleMsgs.turnoff;
            
            // show the old recalc msg
            recalcDiv.innerHTML = recalcDiv.old;
        
        }
        //}
        
        // dis-able your enfunction {
        function disable () {
        
            // show the loading ball
            loadball.style.display = 'block';
        
            // reset the gravlox logo
            gravLox.innerHTML = appName;
        
            // remove the listeners
            Liz.remove();
        
            // disable the slider
            slide0.disabled = true;
            
            // show the disabled toggle msg
            toggleDiv.innerHTML = toggleMsgs.disabled;
            
            // show the disabled recalc msg
            recalcDiv.innerHTML = recalcMsgs.disabled;
            
            // hide any protruding menu
            menu.style.height = '0px';
            
            // uncheck the checkboxes
            checkbox0.checked = false;
            checkbox1.checked = false;
        
        }
        //}
        
        ////////////////////////////////////////////////////////////
        // in principio erat verbum ... {
            
        function init (mlist) {
            
            // begin at zer0 and disabled {
            count = 0;
            disable();
            //}
        
            // set the css vars {
            for (const [keys, vals] of Object.entries(cssProps)) {
                svgHolder.style.setProperty('--' + keys, vals);
            }
            // }
        
            // create the masses {
            masses = mlist.map((m, i) => new Mass(i, ...m));
            //}
        
            // fill the points arrays {
            for (let L in xPts) {
        
                // zero-fill twice the x-dimension plus one for axis
                xPts[L] = (new Array(1 + (2 * xdim))).fill(0)
        
                    // remap the zeros to points at apropos coords
                    .map((p, i) =>
                        new Point((i - xdim) * size, (L - ydim) * size)
                    );
        
            }
        
            // then rotate that points matrix for y-lines
            for (let L in xPts[0]) {
        
                yPts[L] = [];
        
                for (let i in xPts) {
                    yPts[L].push(xPts[i][L]);
                }
        
            }
            //}
        
            // create x-line svgs and objs {
            for (let L of xPts) {
        
                let tmpGL = document.createElementNS(NS, 'path');
                let tmpML = document.createElementNS(NS, 'path');
        
                tmpGL.classList.add('gridline', 'xline');
                tmpML.classList.add('massline');
        
                if (useDots) { tmpL.classList.add('xlineDots'); }
        
                xgridlines.append(tmpGL);
                xmasslines.append(tmpML);
        
                xlineObjs.push(new Line(tmpGL, tmpML, L));
        
            }
            
            // make the centerline the axis
            xlineObjs[ydim].gridobj.classList.add('axisline');
            axgridlines.appendChild(xlineObjs[ydim].gridobj);
            axmasslines.appendChild(xlineObjs[ydim].massobj);
            
            //}
        
            // create y-line svgs and objs {
            for (let L of yPts) {
        
                let tmpGL = document.createElementNS(NS, 'path');
                let tmpML = document.createElementNS(NS, 'path');
        
                tmpGL.classList.add('gridline', 'yline');
                tmpML.classList.add('massline');
        
                ygridlines.appendChild(tmpGL);
                ymasslines.appendChild(tmpML);
        
                ylineObjs.push(new Line(tmpGL, tmpML, L));
        
            }
            
            // make the centerline the axis
            ylineObjs[xdim].gridobj.classList.add('axisline');
            axgridlines.appendChild(ylineObjs[xdim].gridobj);
            axmasslines.appendChild(ylineObjs[xdim].massobj);
            //}
        
            // gen and draw grid at step zer0 {
            xlineObjs.forEach(L => {
                L.genPath(0);
                L.drawPath(0);
            });
            ylineObjs.forEach(L => {
                L.genPath(0);
                L.drawPath(0);
            })
            //}
        
            // run the mass and point loader {
            window.requestAnimationFrame(massPointLoader);
            //}
        
        } init(massList);
        //}
        ////////////////////////////////////////////////////////////

// expire msg {
    
}))()

=== undefined || (console.log('eXp!red'));

// }

</script>

</html>
